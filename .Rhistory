# add land use type
left_join(.,tmp_TT_crops %>% select(crop,land_use_type,species))
# Model Parameters ----
## Constants of the biodiversity value contribution functions ----
# import constants of the biodiversity value contribution functions from Lindner 2019 SM
tmp_param_BV_constant <-  read_excel("data_in/supp_data.xlsx",
sheet = "Lindner_2019_BV_LU_function_con",
col_types = c("text", "text", "numeric",
"numeric", "numeric", "numeric",
"numeric", "numeric"))
tmp_param_BV_constant <- tmp_param_BV_constant %>%
filter(metric_number %in% colnames(tmp_input))
## Variable weighting coefficients ----
tmp_param_var_weight <- tibble(
metric_number = c(
"A.2.1","A.2.2","A.3.1","A.3.2","A.3.3","A.4.3","A.4.5","A.5.1")
) %>%
mutate(
weight = case_when(
metric_number %in% c("A.4.5","A.5.1") ~ 1/3,
.default = (1/3)/(8-2)
)
)
sum(tmp_param_var_weight$weight) == 1
## Land use range ----
tmp_param_LU_range <- tibble(
# set BV_norm min and max according to Lindner et al. (2019)
land_use_type = c("grassland","arable"),
LU_min = c(0.44,0.23),
LU_max = c(0.92,0.52)
)
# BVIAS ----
source("d:/users/srhuet/documents/BiodivLabel/R/BVIAS_functions.R")
tmp <- head(tmp_input[tmp_input$land_use_type == "arable" & tmp_input$org_farming == F,],n = 70) %>%
rbind(.,head(tmp_input[tmp_input$land_use_type == "grassland" & tmp_input$org_farming == F,],n = 30)) %>%
rbind(.,head(tmp_input[tmp_input$land_use_type == "arable" & tmp_input$org_farming == T,],n = 70)) %>%
rbind(.,head(tmp_input[tmp_input$land_use_type == "grassland" & tmp_input$org_farming == T,],n = 30))
tmp_x_norm <- data_for_BVIAS(tmp_input,c("farm_id","crop","land_use_type"),tmp_param_BV_constant)
tmp_BVIAS <- BVIAS(tmp_x_norm,c("farm_id","crop","land_use_type"),tmp_param_BV_constant,tmp_param_var_weight,T)
tmp_optim = optim(tmp_param_BV_constant,BVIAS_loss_function_LU)
tmp_optim = optim(tmp_param_BV_constant,BVIAS_loss_function_LU,method = "L-BFGS-B")
tmp_param_BV_constant
?constrOptim
source("d:/users/srhuet/documents/BiodivLabel/R/BVIAS_functions.R")
tmp_optim = optim(tmp_param_BV_constant,BVIAS_loss_function_LU,method = "L-BFGS-B")
BVIAS_optim1 <- function(var_param) {
library(dplyr)
input = tmp_input
id_cols = c("farm_id","crop","land_use_type")
#var_param = tmp_param_BV_constant
var_weight = tmp_param_var_weight
# model output
tmp_x_norm <- data_for_BVIAS(input,id_cols,var_param)
tmp_BVIAS <- BVIAS(tmp_x_norm,id_cols,var_param,var_weight,F)
# least square difference between model output and average land use type values from Gallego et al., 2022
## estimate variable median for each land use type
tmp_LU_median <- tmp_x_norm %>%
dplyr::group_by(land_use_type,metric_number) %>%
dplyr::summarise(
x_norm = median(x_norm,na.rm = T)
) %>% ungroup()
tmp_BVIAS_median <- BVIAS(tmp_LU_median,c("land_use_type"),var_param,var_weight,F)
# calculate distance from expected values regarding Gallego et al,. 2022
tmp_distance <- tmp_BVIAS_median$BVIAS %>%
dplyr::mutate(
litt_values = case_when(
land_use_type == "arable" ~ 0.32,
land_use_type == "grassland" ~ 0.57
)) %>%
mutate(
distance = case_when(
land_use_type == "arable" ~ (litt_values - BVAS)^2,
land_use_type == "grassland" ~ (litt_values - BVAS)^2
)
) %>% filter(land_use_type == "grassland")
# Erreur quadratique moyenne
tmp_MSE = sum(tmp_distance$distance)/length(tmp_distance$distance)
return(list(MSE = tmp_MSE,input = tmp_BVIAS_median$y,distance_table = tmp_distance))
}
tmp_optim = optim(tmp_param_BV_constant,BVIAS_optim1,method = "L-BFGS-B")
tmp_optim = optim(tmp_param_BV_constant,BVIAS_optim1)
var_param = tmp_param_BV_constant
var_param_v = unlist(tmp_param_BV_constant)
var_param_v
var_param_v = unlist(tmp_param_BV_constant[,3:8])
var_param_v
var_param <- matrix(var_param_v,nrow = 8,ncol = 6)
View(var_param)
tmp_param_var_weight
#var_param = tmp_param_BV_constant
var_weight = tmp_param_var_weight
var_param <- matrix(var_param_v,nrow = 8,ncol = 6) %>% cbind(.,var_weight$metric_number)
View(var_param)
var_param <- tmp_param_BV_constant %>% select(metric_number) %>%
cbind(.,matrix(var_param_v,nrow = 8,ncol = 6))
View(var_param)
colnames(var_param) <- colnames(tmp_param_BV_constant[c(1,3:8)])
colnames(tmp_param_BV_constant[c(1,3:8)])
View(tmp_param_BV_constant)
BVIAS_optim1 <- function(var_param_v) {
library(dplyr)
input = tmp_input
id_cols = c("farm_id","crop","land_use_type")
#var_param = tmp_param_BV_constant
#var_param_v = unlist(tmp_param_BV_constant[,3:8])
var_weight = tmp_param_var_weight
var_param <- tmp_param_BV_constant %>% select(metric_number) %>%
cbind(.,matrix(var_param_v,nrow = 8,ncol = 6))
colnames(var_param) <- colnames(tmp_param_BV_constant[c(1,3:8)])
# model output
tmp_x_norm <- data_for_BVIAS(input,id_cols,var_param)
tmp_BVIAS <- BVIAS(tmp_x_norm,id_cols,var_param,var_weight,F)
# least square difference between model output and average land use type values from Gallego et al., 2022
## estimate variable median for each land use type
tmp_LU_median <- tmp_x_norm %>%
dplyr::group_by(land_use_type,metric_number) %>%
dplyr::summarise(
x_norm = median(x_norm,na.rm = T)
) %>% ungroup()
tmp_BVIAS_median <- BVIAS(tmp_LU_median,c("land_use_type"),var_param,var_weight,F)
# calculate distance from expected values regarding Gallego et al,. 2022
tmp_distance <- tmp_BVIAS_median$BVIAS %>%
dplyr::mutate(
litt_values = case_when(
land_use_type == "arable" ~ 0.32,
land_use_type == "grassland" ~ 0.57
)) %>%
mutate(
distance = case_when(
land_use_type == "arable" ~ (litt_values - BVAS)^2,
land_use_type == "grassland" ~ (litt_values - BVAS)^2
)
) %>% filter(land_use_type == "grassland")
# Erreur quadratique moyenne
tmp_MSE = sum(tmp_distance$distance)/length(tmp_distance$distance)
return(list(MSE = tmp_MSE,input = tmp_BVIAS_median$y,distance_table = tmp_distance))
}
var_param_v = unlist(tmp_param_BV_constant[,3:8])
tmp_optim = optim(var_param_v,BVIAS_optim1)
input = tmp_input
id_cols = c("farm_id","crop","land_use_type")
var_param_v = unlist(tmp_param_BV_constant[,3:8])
#var_param = tmp_param_BV_constant
#var_param_v = unlist(tmp_param_BV_constant[,3:8])
var_weight = tmp_param_var_weight
var_param <- tmp_param_BV_constant %>% select(metric_number) %>%
cbind(.,matrix(var_param_v,nrow = 8,ncol = 6))
colnames(var_param) <- colnames(tmp_param_BV_constant[c(1,3:8)])
# model output
tmp_x_norm <- data_for_BVIAS(input,id_cols,var_param)
tmp_BVIAS <- BVIAS(tmp_x_norm,id_cols,var_param,var_weight,F)
## estimate variable median for each land use type
tmp_LU_median <- tmp_x_norm %>%
dplyr::group_by(land_use_type,metric_number) %>%
dplyr::summarise(
x_norm = median(x_norm,na.rm = T)
) %>% ungroup()
tmp_BVIAS_median <- BVIAS(tmp_LU_median,c("land_use_type"),var_param,var_weight,F)
# calculate distance from expected values regarding Gallego et al,. 2022
tmp_distance <- tmp_BVIAS_median$BVIAS %>%
dplyr::mutate(
litt_values = case_when(
land_use_type == "arable" ~ 0.32,
land_use_type == "grassland" ~ 0.57
)) %>%
mutate(
distance = case_when(
land_use_type == "arable" ~ (litt_values - BVAS)^2,
land_use_type == "grassland" ~ (litt_values - BVAS)^2
)
) %>% filter(land_use_type == "grassland")
# Erreur quadratique moyenne
tmp_MSE = sum(tmp_distance$distance)/length(tmp_distance$distance)
source("d:/users/srhuet/documents/BiodivLabel/R/BVIAS_functions.R")
var_param_v = unlist(tmp_param_BV_constant[,3:8])
tmp_optim = optim(var_param_v,BVIAS_optim1)
var_param_v = unlist(tmp_param_BV_constant[,3:8])
tmp_optim = optim(var_param_v,BVIAS_optim1)
source("d:/users/srhuet/documents/BiodivLabel/R/BVIAS_functions.R")
var_param_v = unlist(tmp_param_BV_constant[,3:8])
tmp_optim = optim(var_param_v,BVIAS_optim1)
var_param_v = unlist(tmp_param_BV_constant[,3:8])
tmp_optim = optim(var_param_v,BVIAS_optim1)
source("d:/users/srhuet/documents/BiodivLabel/R/BVIAS_functions.R")
tmp_optim = optim(var_param_v,BVIAS_optim1)
source("d:/users/srhuet/documents/BiodivLabel/R/BVIAS_functions.R")
var_param_v = unlist(tmp_param_BV_constant[,3:8])
tmp_optim = optim(var_param_v,BVIAS_optim1)
var_param_v = unlist(tmp_param_BV_constant[,3:8])
tmp_optim = optim(var_param_v,BVIAS_optim1)
View(tmp_optim)
matrix(tmp_optim$par)
matrix(tmp_optim$par,nrow = 8,ncol = 6)
matrix(var_param_v,nrow = 8,ncol = 6)
library(gt)
library(dplyr)
#| label: tbl-methods
#| tbl-cap: "**Exigences de l’affichage environnemental et méthodes existantes.** Le code couleur donne le jugement des auteurs sur le degré d’adéquation du type de méthode avec chaque critère (exigence [remplie]{style=color:#99CC99;}, [partiellement remplie]{style=color:#FFCC99;} ou [pas remplie]{style=color:#FF9999;}), en prenant appui sur l’exemple cité en haut de tableau."
tmp_table <- data.frame(
`X`= c(
"Définition explicite et opérationnelle de la biodiversité",
"Prise en compte des principaux déterminants de pertes de biodiversité liés à l'agriculture",
"Occupation des sols",
"Changement climatique",
"Pollution",
"Reposer sur des données mesurées, sur la biodiversité ou sur les pratiques, au niveau des exploitations",
"Permettre une estimation par défaut sur tout produit alimentaire",
"Validation sur la base de mesures in situ de biodiversité"),
`Observations in situ (ex. Tuck et al., 2014)` = c(
"Diversité spécifique (d’autres études présentent une pluralité d'indicateurs dont l’abondance, la diversité, la présence d’espèces rares/endémiques, …). Absence de lien systématique avec la sixième crise d’extinction.",
"",
"Prise en compte des effets paysagers. Pas de prise en compte des rendements.",
"Non pris en compte",
"Prise en compte intrinsèque de toutes les pollutions",
"Oui (biodiversité), mais sans garantie sur la représentativité des parcelles (taille d’échantillon souvent faible, difficulté à couvrir l’ensemble des productions)",
"Non (trop peu de mesures pour différentier chaque produit)",
"Oui (intrinsèquement)"),
`Modélisation à partir de données sur les pratiques agricoles (ex. Lindner and Koch, 2022)` = c(
"Dégradation de l’état naturel (ou risque d’extinction d’espèces pour d’autres études)",
"",
"Pas de prise en compte des effets paysagers. Prise en compte des rendements",
"Non pris en compte par Lindner et al. (2022), mais pris en compte par d’autres modèles",
"Prise en compte des principales pollutions sans taille d’effet",
"Oui (pratiques), mais souvent incomplètes et sans garantie sur la représentativité (inventaires de cycle de vie)",
"Différencie les principaux produits, et le label bio",
"Non"
),
`Modélisation à partir de cahiers des charges (ex. Alliot et al., 2021)` = c(
"Définition implicite",
"",
"Prise en compte des effets paysagers. Pas de prise en compte des rendements.",
"Non pris en compte",
"Prise en compte des principales pollutions sans taille d’effet",
"Non (cahier des charges)",
"Différencie de nombreux labels, mais pas les produits entre eux",
"Non"
),
`BVIAS (cette étude)` = c(
"Dégradation de l’état naturel",
"",
"Prise en compte des effets paysagers et des rendements",
"Non pris en compte",
"Prise en compte des principales pollutions avec taille d’effet",
"Oui (pratiques, échantillon fourni et représentatif : RICA, RA, RPG)",
"Différencie les principaux produits, et les labels suffisamment représentés",
"Oui (ordres de grandeur consensuels dans la littérature)"
)
) %>%
# add columns for color
mutate(
#col1 = c(0,0,0,0,0,0,0,0),
col2 = c(2,0,2,1,3,3,1,3),
col3 = c(3,0,2,2,2,2,3,1),
col4 = c(2,0,2,1,2,1,2,1),
col5 = c(3,0,3,1,3,3,3,3)
)
tmp_palette = c("#FF9999","#FFCC99", "#99CC99")
tmp_table %>%
gt() %>%
data_color(   columns = col2,
target_columns = Observations.in.situ..ex..Tuck.et.al...2014.,
rows = col2 >0,
method = "numeric",
palette = tmp_palette,
domain = c(1,3)
) %>%
data_color(   columns = col3,
target_columns = Modélisation.à.partir.de.données.sur.les.pratiques.agricoles..ex..Lindner.and.Koch..2022.,
rows = col3 >0,
method = "numeric",
palette = tmp_palette,
domain = c(1,3)
) %>%
data_color(   columns = col4,
target_columns = Modélisation.à.partir.de.cahiers.des.charges..ex..Alliot.et.al...2021.,
rows = col4 >0,
method = "numeric",
palette = tmp_palette,
domain = c(1,3)
) %>%
data_color(   columns = col5,
target_columns = BVIAS..cette.étude.,
rows = col5 >0,
method = "numeric",
palette = tmp_palette,
domain = c(1,3)
) %>%
cols_hide(col2:col5)
#rm(tmp_table)
tmp_table <- data.frame(
x1= c("",
"Définition explicite et opérationnelle de la biodiversité",
"Prise en compte des principaux déterminants de pertes de biodiversité liés à l'agriculture",
"Occupation des sols",
"Changement climatique",
"Pollution",
"Reposer sur des données mesurées, sur la biodiversité ou sur les pratiques, au niveau des exploitations",
"Permettre une estimation par défaut sur tout produit alimentaire",
"Validation sur la base de mesures in situ de biodiversité"),
x2 = c("Observations in situ (ex. Tuck et al., 2014)",
"Diversité spécifique (d’autres études présentent une pluralité d'indicateurs dont l’abondance, la diversité, la présence d’espèces rares/endémiques, …). Absence de lien systématique avec la sixième crise d’extinction.",
"",
"Prise en compte des effets paysagers. Pas de prise en compte des rendements.",
"Non pris en compte",
"Prise en compte intrinsèque de toutes les pollutions",
"Oui (biodiversité), mais sans garantie sur la représentativité des parcelles (taille d’échantillon souvent faible, difficulté à couvrir l’ensemble des productions)",
"Non (trop peu de mesures pour différentier chaque produit)",
"Oui (intrinsèquement)"),
x3 = c("Modélisation à partir de données sur les pratiques agricoles (ex. Lindner and Koch, 2022)",
"Dégradation de l’état naturel (ou risque d’extinction d’espèces pour d’autres études)",
"",
"Pas de prise en compte des effets paysagers. Prise en compte des rendements",
"Non pris en compte par Lindner et al. (2022), mais pris en compte par d’autres modèles",
"Prise en compte des principales pollutions sans taille d’effet",
"Oui (pratiques), mais souvent incomplètes et sans garantie sur la représentativité (inventaires de cycle de vie)",
"Différencie les principaux produits, et le label bio",
"Non"
),
x4 = c("Modélisation à partir de cahiers des charges (ex. Alliot et al., 2021)",
"Définition implicite",
"",
"Prise en compte des effets paysagers. Pas de prise en compte des rendements.",
"Non pris en compte",
"Prise en compte des principales pollutions sans taille d’effet",
"Non (cahier des charges)",
"Différencie de nombreux labels, mais pas les produits entre eux",
"Non"
),
x5 = c("BVIAS (cette étude)",
"Dégradation de l’état naturel",
"",
"Prise en compte des effets paysagers et des rendements",
"Non pris en compte",
"Prise en compte des principales pollutions avec taille d’effet",
"Oui (pratiques, échantillon fourni et représentatif : RICA, RA, RPG)",
"Différencie les principaux produits, et les labels suffisamment représentés",
"Oui (ordres de grandeur consensuels dans la littérature)"
)
) %>%
# add columns for color
mutate(
#col1 = c(0,0,0,0,0,0,0,0),
col2 = c(0,2,0,2,1,3,3,1,3),
col3 = c(0,3,0,2,2,2,2,3,1),
col4 = c(0,2,0,2,1,2,1,2,1),
col5 = c(0,3,0,3,1,3,3,3,3)
)
tmp_palette = c("#FF9999","#FFCC99", "#99CC99")
tmp_table %>%
gt() %>%
data_color(   columns = col2,
target_columns = x2,
rows = col2 >0,
method = "numeric",
palette = tmp_palette,
domain = c(1,3)
) %>%
data_color(   columns = col3,
target_columns = x3,
rows = col3 >0,
method = "numeric",
palette = tmp_palette,
domain = c(1,3)
) %>%
data_color(   columns = col4,
target_columns =x4,
rows = col4 >0,
method = "numeric",
palette = tmp_palette,
domain = c(1,3)
) %>%
data_color(   columns = col5,
target_columns = x5,
rows = col5 >0,
method = "numeric",
palette = tmp_palette,
domain = c(1,3)
) %>%
cols_hide(col2:col5) %>%
gt::rm_header()
tmp_table %>%
gt() %>%
data_color(   columns = col2,
target_columns = x2,
rows = col2 >0,
method = "numeric",
palette = tmp_palette,
domain = c(1,3)
) %>%
data_color(   columns = col3,
target_columns = x3,
rows = col3 >0,
method = "numeric",
palette = tmp_palette,
domain = c(1,3)
) %>%
data_color(   columns = col4,
target_columns =x4,
rows = col4 >0,
method = "numeric",
palette = tmp_palette,
domain = c(1,3)
) %>%
data_color(   columns = col5,
target_columns = x5,
rows = col5 >0,
method = "numeric",
palette = tmp_palette,
domain = c(1,3)
) %>%
cols_hide(col2:col5) %>%
rm_header()
#| label: tbl-methods
#| tbl-cap: "**Environmental Labeling Requirements and Existing Methods.** The colour code gives the authors' judgement on the degree of adequacy of the type of method with each criterion (requirement [fulfilled]{style=color:#99CC99;}, [partially fulfilled]{style=color:#FFCC99;} or [not fulfilled]{style=color:#FF9999;}), based on the example cited at the top of the table."
tmp_table <- data.frame(
x1= c(
"",
"Explicit and operational definition of biodiversity",
"Addressing the main determinants of biodiversity loss related to agriculture",
"Land use",
"Climate change",
"Pollution",
"Based on measured data, biodiversity or practices at the farm level",
"Allow a default estimate on any food product",
"Validation based on biodiversity measurements"
),
x2 = c(
"In situ observations (e.g., Tuck et al., 2014)",
"Specific diversity (other studies present a plurality of indicators including abundance, diversity, presence of rare/endemic species,...).No systematic link with the sixth extinction crisis.",
"",
"Consideration of landscape effects. No consideration of yields",
"Not taken into account",
"Taking into account all pollution",
"Yes (biodiversity), but without guarantee on the representativeness of the plots (sample size often small, difficulty in covering all productions)",
"No (too few measurements to differentiate each product)",
"Yes (intrinsically)"
),
x3 = c(
"Modelling from agricultural practices data (e.g. Lindner and Koch, 2022)",
"Degradation of natural state (or risk of extinction of species for other studies)",
"",
"No account taken of landscape effects. Consideration of yields",
"Not considered by Lindner et al. (2022), but considered by other models",
"Taking into account the main pollutions without effect size",
"Yes (practices), but often incomplete and without representativeness assurance (life cycle inventories)",
"Differentiates the main products, and the organic label",
"No"
),
x4 = c(
"Modelling from specifications (e.g. Alliot et al., 2021) ",
"Implied definition",
"",
"Consideration of landscape effects. No consideration of yields",
"Not taken into account",
"Taking into account the main pollutions without effect size",
"No (specification)",
"Differentiates many labels, but not products between them",
"No"
),
x5 = c(
"BVI AD (this study)",
"Degradation of natural state",
"",
"Consideration of landscape effects and yields",
"Not taken into account",
"Taking into account the main pollutions with effect size",
"Yes (practices, sample provided and representative: FADN, AC, LPIS)",
"Differentiates the main products, and labels sufficiently represented",
"Yes (consensus orders of magnitude in the literature)"
)
) %>%
# add columns for color
mutate(
#col1 = c(0,0,0,0,0,0,0,0),
col2 = c(0,2,0,2,1,3,3,1,3),
col3 = c(0,3,0,2,2,2,2,3,1),
col4 = c(0,2,0,2,1,2,1,2,1),
col5 = c(0,3,0,3,1,3,3,3,3)
)
tmp_palette = c("#FF9999","#FFCC99", "#99CC99")
tmp_table %>%
gt() %>%
data_color(   columns = col2,
target_columns = x2,
rows = col2 >0,
method = "numeric",
palette = tmp_palette,
domain = c(1,3)
) %>%
data_color(   columns = col3,
target_columns = x3,
rows = col3 >0,
method = "numeric",
palette = tmp_palette,
domain = c(1,3)
) %>%
data_color(   columns = col4,
target_columns =x4,
rows = col4 >0,
method = "numeric",
palette = tmp_palette,
domain = c(1,3)
) %>%
data_color(   columns = col5,
target_columns = x5,
rows = col5 >0,
method = "numeric",
palette = tmp_palette,
domain = c(1,3)
) %>%
cols_hide(col2:col5)
#rm(tmp_table)
