---
title: "BVIAS_optimization_ShinyApp"
format: html
editor: source
author: Sarah HUET
date: 2024-07-31
---
```{r inputs}

# Set up ----

library(dplyr)
library(tidyr)
library(readxl)

# Input data ----

if (my_DB == "RICA") {

  # transfert table
  tmp_TT_crops <- read_xlsx("d:/users/srhuet/documents/BiodivLabel/data_in/supp_data.xlsx",sheet = "TT_crops") %>%
    rename(crop = RICA_code_number)
}

if (my_DB == "FADN") {

  # transfert table
  tmp_FADN_crops <- read_xlsx("d:/users/srhuet/documents/BiodivLabel/data_in/supp_data.xlsx",sheet = "FADN_crop_code")
  tmp_TT_crops0 <- read_xlsx("d:/users/srhuet/documents/BiodivLabel/data_in/supp_data.xlsx",sheet = "TT_crops")
  tmp_TT_crops <- left_join(
    tmp_FADN_crops %>% rename(crop = code_letter),
    tmp_TT_crops0 %>% rename(crop = FADN_code_letter) %>% select(crop,species)
  ) %>% distinct()

}

# Input variables ----

# WIP est-ce la bonne manière de joindre les df pour ne pas garder les fermes qu'on a retiré à chaque paramètre ???
tmp_farms <- Reduce(intersect,list(
  BV_A.2.1$farm_id,
  BV_A.2.2$farm_id,
  BV_A.3.1$farm_id,
  BV_A.3.2$farm_id,
  BV_A.3.3$farm_id,
  BV_A.4.3$farm_id,
  BV_A.4.5$farm_id,
  BV_A.5.1$farm_id))
# RICA2020: 6091 farms
# FADN2018: 60221 farms / 81288

tmp_input <- Reduce(inner_join,list(
  BV_A.4.5 %>% filter(farm_id %in% tmp_farms),
  BV_A.2.1 %>% filter(farm_id %in% tmp_farms),
  BV_A.2.2 %>% filter(farm_id %in% tmp_farms),
  BV_A.3.1 %>% filter(farm_id %in% tmp_farms),
  BV_A.3.2 %>% filter(farm_id %in% tmp_farms),
  BV_A.3.3 %>% filter(farm_id %in% tmp_farms),
  BV_A.4.3 %>% filter(farm_id %in% tmp_farms),
  BV_A.5.1 %>% filter(farm_id %in% tmp_farms)
)) %>% ungroup() %>%
  # add land use type
  left_join(.,tmp_TT_crops %>% select(crop,land_use_type,species))

# Model Parameters ----

## Constants of the biodiversity value contribution functions ----

# import constants of the biodiversity value contribution functions from Lindner 2019 SM
tmp_param_BV_constant <-  read_excel("d:/users/srhuet/documents/BiodivLabel/data_in/supp_data.xlsx",
                               sheet = "Lindner_2019_BV_LU_function_con",
                               col_types = c("text", "text", "numeric",
                                             "numeric", "numeric", "numeric",
                                             "numeric", "numeric"))
tmp_param_BV_constant <- tmp_param_BV_constant %>%
  filter(metric_number %in% colnames(tmp_input))



## Variable weighting coefficients ----

tmp_param_var_weight <- tibble(
  metric_number = c(
    "A.2.1","A.2.2","A.3.1","A.3.2","A.3.3","A.4.3","A.4.5","A.5.1")
  ) %>%
  mutate(
    weight = case_when(
      metric_number %in% c("A.4.5","A.5.1") ~ 1/3,
      .default = (1/3)/(8-2)

    )
  )
sum(tmp_param_var_weight$weight) == 1

## Land use range ----

tmp_param_LU_range <- tibble(
  # set BV_norm min and max according to Lindner et al. (2019)
  land_use_type = c("grassland","arable"),
  LU_min = c(0.44,0.23),
  LU_max = c(0.92,0.52)
)

source("d:/users/srhuet/documents/BiodivLabel/R/BVIAS_functions.R")
tmp_x_norm <- data_for_BVIAS(input,id_cols,var_param)



```

```{r, eval=FALSE}
library(shiny)
library(ggplot2)

input = tmp_input[1:100,]
id_cols = c("farm_id","crop","land_use_type")
var_param = tmp_param_BV_constant
var_weight = tmp_param_var_weight

# Define UI for application that draws a histogram
ui <- fluidPage(
  titlePanel("App to optimize model parameters"),
  
  # Sidebar with a slider input for the number of bins
  sidebarLayout(
    sidebarPanel(
      h2("Slider inputs:"),
      
      sliderInput("A.2.1__alpha","A.2.1__alpha",min = -1, max = 10, value = tmp_param_BV_constant$alpha[1]),
      sliderInput("A.2.2__alpha","A.2.2__alpha",min = -1, max = 10, value = tmp_param_BV_constant$alpha[2]),
      sliderInput("A.3.1__alpha","A.3.1__alpha",min = -1, max = 10, value = tmp_param_BV_constant$alpha[3]),
      sliderInput("A.3.2__alpha","A.3.2__alpha",min = -1, max = 10, value = tmp_param_BV_constant$alpha[4]),
      sliderInput("A.3.3__alpha","A.3.3__alpha",min = -1, max = 10, value = tmp_param_BV_constant$alpha[5]),
      sliderInput("A.4.3__alpha","A.4.3__alpha",min = -1, max = 10, value = tmp_param_BV_constant$alpha[6]),
      sliderInput("A.4.5__alpha","A.4.5__alpha",min = -1, max = 10, value = tmp_param_BV_constant$alpha[7]),
      sliderInput("A.5.1__alpha","A.5.1__alpha",min = -1, max = 10, value = tmp_param_BV_constant$alpha[8]),
      sliderInput("A.2.1__sigma","A.2.1__sigma",min = -1, max = 10, value = tmp_param_BV_constant$sigma[1]),
      sliderInput("A.2.2__sigma","A.2.2__sigma",min = -1, max = 10, value = tmp_param_BV_constant$sigma[2]),
      sliderInput("A.3.1__sigma","A.3.1__sigma",min = -1, max = 10, value = tmp_param_BV_constant$sigma[3]),
      sliderInput("A.3.2__sigma","A.3.2__sigma",min = -1, max = 10, value = tmp_param_BV_constant$sigma[4]),
      sliderInput("A.3.3__sigma","A.3.3__sigma",min = -1, max = 10, value = tmp_param_BV_constant$sigma[5]),
      sliderInput("A.4.3__sigma","A.4.3__sigma",min = -1, max = 10, value = tmp_param_BV_constant$sigma[6]),
      sliderInput("A.4.5__sigma","A.4.5__sigma",min = -1, max = 10, value = tmp_param_BV_constant$sigma[7]),
      sliderInput("A.5.1__sigma","A.5.1__sigma",min = -1, max = 10, value = tmp_param_BV_constant$sigma[8]),
      sliderInput("A.2.1__beta","A.2.1__beta",min = -1, max = 10, value = tmp_param_BV_constant$beta[1]),
      sliderInput("A.2.2__beta","A.2.2__beta",min = -1, max = 10, value = tmp_param_BV_constant$beta[2]),
      sliderInput("A.3.1__beta","A.3.1__beta",min = -1, max = 10, value = tmp_param_BV_constant$beta[3]),
      sliderInput("A.3.2__beta","A.3.2__beta",min = -1, max = 10, value = tmp_param_BV_constant$beta[4]),
      sliderInput("A.3.3__beta","A.3.3__beta",min = -1, max = 10, value = tmp_param_BV_constant$beta[5]),
      sliderInput("A.4.3__beta","A.4.3__beta",min = -1, max = 10, value = tmp_param_BV_constant$beta[6]),
      sliderInput("A.4.5__beta","A.4.5__beta",min = -1, max = 10, value = tmp_param_BV_constant$beta[7]),
      sliderInput("A.5.1__beta","A.5.1__beta",min = -1, max = 10, value = tmp_param_BV_constant$beta[8]),
      sliderInput("A.2.1__gamma","A.2.1__gamma",min = -1, max = 10, value = tmp_param_BV_constant$gamma[1]),
      sliderInput("A.2.2__gamma","A.2.2__gamma",min = -1, max = 10, value = tmp_param_BV_constant$gamma[2]),
      sliderInput("A.3.1__gamma","A.3.1__gamma",min = -1, max = 10, value = tmp_param_BV_constant$gamma[3]),
      sliderInput("A.3.2__gamma","A.3.2__gamma",min = -1, max = 10, value = tmp_param_BV_constant$gamma[4]),
      sliderInput("A.3.3__gamma","A.3.3__gamma",min = -1, max = 10, value = tmp_param_BV_constant$gamma[5]),
      sliderInput("A.4.3__gamma","A.4.3__gamma",min = -1, max = 10, value = tmp_param_BV_constant$gamma[6]),
      sliderInput("A.4.5__gamma","A.4.5__gamma",min = -1, max = 10, value = tmp_param_BV_constant$gamma[7]),
      sliderInput("A.5.1__gamma","A.5.1__gamma",min = -1, max = 10, value = tmp_param_BV_constant$gamma[8]),
      sliderInput("A.2.1__delta","A.2.1__delta",min = -1, max = 10, value = tmp_param_BV_constant$delta[1]),
      sliderInput("A.2.2__delta","A.2.2__delta",min = -1, max = 10, value = tmp_param_BV_constant$delta[2]),
      sliderInput("A.3.1__delta","A.3.1__delta",min = -1, max = 10, value = tmp_param_BV_constant$delta[3]),
      sliderInput("A.3.2__delta","A.3.2__delta",min = -1, max = 10, value = tmp_param_BV_constant$delta[4]),
      sliderInput("A.3.3__delta","A.3.3__delta",min = -1, max = 10, value = tmp_param_BV_constant$delta[5]),
      sliderInput("A.4.3__delta","A.4.3__delta",min = -1, max = 10, value = tmp_param_BV_constant$delta[6]),
      sliderInput("A.4.5__delta","A.4.5__delta",min = -1, max = 10, value = tmp_param_BV_constant$delta[7]),
      sliderInput("A.5.1__delta","A.5.1__delta",min = -1, max = 10, value = tmp_param_BV_constant$delta[8]),
      sliderInput("A.2.1__epsilon","A.2.1__epsilon",min = -1, max = 10, value = tmp_param_BV_constant$epsilon[1]),
      sliderInput("A.2.2__epsilon","A.2.2__epsilon",min = -1, max = 10, value = tmp_param_BV_constant$epsilon[2]),
      sliderInput("A.3.1__epsilon","A.3.1__epsilon",min = -1, max = 10, value = tmp_param_BV_constant$epsilon[3]),
      sliderInput("A.3.2__epsilon","A.3.2__epsilon",min = -1, max = 10, value = tmp_param_BV_constant$epsilon[4]),
      sliderInput("A.3.3__epsilon","A.3.3__epsilon",min = -1, max = 10, value = tmp_param_BV_constant$epsilon[5]),
      sliderInput("A.4.3__epsilon","A.4.3__epsilon",min = -1, max = 10, value = tmp_param_BV_constant$epsilon[6]),
      sliderInput("A.4.5__epsilon","A.4.5__epsilon",min = -1, max = 10, value = tmp_param_BV_constant$epsilon[7]),
      sliderInput("A.5.1__epsilon","A.5.1__epsilon",min = -1, max = 10, value = tmp_param_BV_constant$epsilon[8])
      ),
      
    
    # Show a plot of the generated distribution
    mainPanel(
      
      h2("Mean squared error:"),
      
      textOutput('previous_mse'),
      br(),
      textOutput('new_mse')
    )
  )
)



# Define server logic required to draw a histogram
server <- function(input, output) {
  
    # Previous MSE:
  output$previous_mse <- renderText({
    

  # model output
  tmp_BVIAS <- BVIAS(tmp_x_norm,id_cols,var_param,var_weight,F)

  # least square difference between model output and average land use type values from Gallego et al., 2022

  ## estimate variable median for each land use type
  tmp_LU_median <- tmp_x_norm %>%
    dplyr::group_by(land_use_type,metric_number) %>%
    dplyr::summarise(
      x_norm = median(x_norm,na.rm = T)
    ) %>% ungroup()


  tmp_BVIAS_median <- BVIAS(tmp_LU_median,c("land_use_type"),var_param,var_weight,F)

  # calculate distance from expected values regarding Gallego et al,. 2022
  tmp_distance <- tmp_BVIAS_median$BVIAS %>%
    dplyr::mutate(
      litt_values = case_when(
        land_use_type == "arable" ~ 0.32,
        land_use_type == "grassland" ~ 0.57
      )) %>%
    mutate(
      distance = case_when(
        land_use_type == "arable" ~ (litt_values - BVAS)^2,
        land_use_type == "grassland" ~ (litt_values - BVAS)^2
      )
    )

  # Erreur quadratique moyenne
  mse = sum(tmp_distance$distance)/length(tmp_distance$distance)
    
  })
  
  # New MSE:
  output$new_mse <- renderText({
    
    # gather new parameters
    tmp_new_param <- tibble(
      "metric_number" = tmp_param_BV_constant$metric_number,
      "alpha" = c( input$A.2.1__alpha, input$A.2.2__alpha, input$A.3.1__alpha, input$A.3.2__alpha, input$A.3.3__alpha, input$A.4.3__alpha, input$A.4.5__alpha, input$A.5.1__alpha),
      "sigma" = c( input$A.2.1__sigma, input$A.2.2__sigma, input$A.3.1__sigma, input$A.3.2__sigma, input$A.3.3__sigma, input$A.4.3__sigma, input$A.4.5__sigma, input$A.5.1__sigma),
      "beta" = c( input$A.2.1__beta, input$A.2.2__beta, input$A.3.1__beta, input$A.3.2__beta, input$A.3.3__beta, input$A.4.3__beta, input$A.4.5__beta, input$A.5.1__beta),
      "gamma" = c( input$A.2.1__gamma, input$A.2.2__gamma, input$A.3.1__gamma, input$A.3.2__gamma, input$A.3.3__gamma, input$A.4.3__gamma, input$A.4.5__gamma, input$A.5.1__gamma),
      "delta" = c( input$A.2.1__delta, input$A.2.2__delta, input$A.3.1__delta, input$A.3.2__delta, input$A.3.3__delta, input$A.4.3__delta, input$A.4.5__delta, input$A.5.1__delta),
      "epsilon" = c( input$A.2.1__epsilon, input$A.2.2__epsilon, input$A.3.1__epsilon, input$A.3.2__epsilon, input$A.3.3__epsilon, input$A.4.3__epsilon, input$A.4.5__epsilon, input$A.5.1__epsilon))

          # model output
  tmp_BVIAS <- BVIAS(tmp_x_norm,id_cols,tmp_new_param,var_weight,F)

  # least square difference between model output and average land use type values from Gallego et al., 2022

  ## estimate variable median for each land use type
  tmp_LU_median <- tmp_x_norm %>%
    dplyr::group_by(land_use_type,metric_number) %>%
    dplyr::summarise(
      x_norm = median(x_norm,na.rm = T)
    ) %>% ungroup()


  tmp_BVIAS_median <- BVIAS(tmp_LU_median,c("land_use_type"),tmp_new_param,var_weight,F)

  # calculate distance from expected values regarding Gallego et al,. 2022
  tmp_distance <- tmp_BVIAS_median$BVIAS %>%
    dplyr::mutate(
      litt_values = case_when(
        land_use_type == "arable" ~ 0.32,
        land_use_type == "grassland" ~ 0.57
      )) %>%
    mutate(
      distance = case_when(
        land_use_type == "arable" ~ (litt_values - BVAS)^2,
        land_use_type == "grassland" ~ (litt_values - BVAS)^2
      )
    )

  # Erreur quadratique moyenne
  mse = sum(tmp_distance$distance)/length(tmp_distance$distance)

    
  })
  
    # Create histogram of the previous MSE:
    output$hist1 <- renderPlot({
      plot_data <- tibble(
        "mse_name"= c("Initial MSE","Previous MSE"),
        "mse" = c(output$previous_mse,output$new_mse))
      
      ggplot(plot_data, aes(x=mse_name,y=mse)) + geom_histogram()})
  
  
}


# Run the application 
shinyApp(ui = ui, server = server)

```



